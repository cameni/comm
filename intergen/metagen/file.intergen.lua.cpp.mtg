
//@file $name$ lua interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_lua_capi.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>
#include <comm/log/logger.h>

$-[class]$$[iface]$
#include "$relpathlua$"
$-[/iface]$$[/class]$

using namespace coid;

$-[class]$$[iface rest="\n\n"]$
////////////////////////////////////////////////////////////////////////////////
//
// lua handler of interface $name$ of class $..class$
//
////////////////////////////////////////////////////////////////////////////////

$-[ns]$
namespace $@value$ {
$-[/ns]$
namespace lua {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty?)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$_lua_dispatcher
    : public ::lua::interface_wrapper_base<$ns rest="::"$::$name$>
{
$-(if event?)$
    mutable iref<::lua::weak_registry_handle> _events[$event.@size$];
    mutable bool _bound_events;

    void init_event_registry() {
        for (int i = 0; i < $event.@size$; i++) {
            _events[i] = new ::lua::weak_registry_handle;
        }
    }

$-(/if)$
$-(if hasprops?)$
    // !!! TODO !!! has props
$-(/if)$
protected:

    backend intergen_backend() const override { return backend::lua; }
    static const coid::token& lua_interface_class_name() { static const coid::token _lua_class_name = "$ns rest="_" after="_"$$name$"; return _lua_class_name; };

public:

    iref<::lua::registry_handle> create_interface_object(bool make_weak);
$-(if event?)$
    void bind_events( bool force, iref<::lua::registry_handle> binding_object, const coid::token& script_class_name ) const;
$-(/if)$

    COIDNEWDELETE($name$_lua_dispatcher);

    $name$_lua_dispatcher() $-(if event?)$ : _bound_events(false)$(/if)$
    {
$-(if event?)$
        init_event_registry();
$(/if)-$
    }

    $name$_lua_dispatcher(iref<::lua::registry_handle> context, $ns rest="::" after="::"$$name$* orig ) $(if event?)$: _bound_events(false) $(/if)${
        _base.create(orig);
        _vtable = _base->vtable();

        _context->set_state(context->get_state());
        context->get_ref();
        _context->set_ref();

        _host = _base->host<policy_intrusive_base>();

$-(if event?)$
        init_event_registry();
$(/if)-$
    }

    ~$name$_lua_dispatcher() {

    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- registrar ---
    static int register_interface_$name$(lua_State * L);
    static int register_implementation_$name$(lua_State * L, const coid::token& implementation_script_class_name);

    // --- creators ---

$-[method creator? !ifccr?]$
$(if !comments.empty?)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$_lua_dispatcher> $name$(lua_State * L, const ::lua::script_handle& scriptpath
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bind_class_name, const coid::token& bind_var_name, iref<::lua::registry_handle>* );

    $-(if !internal?)$
    static int luacreator_$name$$@order$(lua_State * L, ::lua::interface_context* ifc);
    $-(/if)$
$-[/method]$

    static int lualog_exc(lua_State * L);
    static int lualog(lua_State * L);
    static int luaquery_interface_exc(lua_State * L);
    static int luaquery_interface(lua_State * L);
    static int luarebind_events_exc(lua_State * L);
    static int luarebind_events(lua_State * L);


    // --- method wrappers ---

$-[method !static? !destroy? !internal? !operator?]$
    static int lua_$name$$@index$_exc( lua_State * L );
    static int lua_$name$$@index$( lua_State * L );
    static bool can_use_ffi_$name$$@index$();
    static void get_ffi_inject_$name$$@index$(coid::token& header, coid::token& body);
    static $return.type$ lua_$name$$@index$_ffi(void * ifc_this $-[args]$, $type$ $name$$size$$[/ args]$);
$-[/method]$
$-(if event.empty!)$

    // --- interface events ---

$-[event]$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) $-(if const?)$ const$(/if)$ override;
$-[/event]$

$-[event]$
    virtual bool is_bound_$name$() override { return is_event_bound($@index$); }
$-[/event]$

virtual void force_bind_script_events() {
    DASSERT(0);
    //bind_events( true, iref<::lua::registry_handle>(&::lua::registry_handle()));
}

private:
    bool is_event_bound(int id)
    {
        /*if (!_bound_events) {
            bind_events( false, iref<::lua::registry_handle>(&::lua::registry_handle()));
        }*/

        return _bound_events && _events[id];
    }

    //event wrappers for event invocation from lua
$-[event]$
    static int lua_evback_$name$$@index$( lua_State * L );
$-[/event]$
$-(/if)$
};

$-[method !static? !destroy? !internal? !operator?]$
////////////////////////////////////////////////////////////////////////////////
//
//  $return.type$ $..ns rest="::" after="::"$$..name$::$name$($[args rest=","]$ $type$ $name$$[/args]$)
//
__declspec(noinline) int $..name$_lua_dispatcher::lua_$name$$@index$_exc( lua_State * L )
{
    bool exception_thrown = false;

    try {
        const int args_count = lua_gettop(L) - 1;

        if (args_count < $ninargs_nondef$ || args_count > $ninargs$) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "$..name$.$name$";
            throw coid::exception(tmp);
        }

        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_cthis_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "$..name$.$name$";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_cthis_key);

        ::lua::interface_wrapper_base<$..ns rest = "::"$::$..name$>* ifc = reinterpret_cast<::lua::interface_wrapper_base<$..ns rest = "::"$::$..name$>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "$..name$.$name$";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

        //stream the arguments in
$-[args inarg? !nojs?]$

        lua_pushvalue(L, $@order$ + 2);
    $-(if iref.true?)$
        $basetype$ $name$;
        $-(if !defval.empty?)$
        if ($@order$ < args_count)
            from_lua($name$);
        else
            $name$ = $defval$;
        $-(elif)$
        from_lua($name$);
        $-(/if)$
    $-(elif)$
        static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator '$basetype$'");
        $-(if !defval.empty? ptr.true?)$
        threadcached<$basetype$> $name$__tmp;
        $basetype$ *$name$ = &$name$__tmp;
        if ($@order$ < args_count)
            from_lua($name$__tmp);
        else
            $name$ = $defval$;
        $-(elif !defval.empty?)$
        threadcached<$basetype$> $name$;
        if ($@order$ < args_count)
            from_lua($name$);
        else
            $name$ = $defval$;
        $-(elif)$
            threadcached<$basetype$> $name$;
        from_lua($name$);
        $-(/if)$
    $-(/if)$
$-[/args]$

//out params
$-[args outarg? !inarg?]$
        $basetype$ $name$;
$-[/args]$

// invoke
        $(if return.type!="void")$$return.type$ _rval_ = $(/if)$R_->$name$($[args rest=", "]$ $-(if ptr? outarg?)$&$-(elif ptr? defval.empty? !specptr?)$&$(/if)$ $-(if nojs?)$$defval$$(elif)$$name$$(/if)$$[/args]$);

//stream out
        THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

$-(if return.type!="void")$
    $-(if noutargs?)$
        const uint _res_count = $noutargs$ + 1;
        lua_createtable(L,0,_res_count);
        $-(if return.iref.false?)$
        static_assert(CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'");
        to_lua(_rval_);
        $-(elif)$
        if (!_rval_.is_empty()){
            iref<::lua::registry_handle> _rval_handle = ::lua::wrap_object(_rval_.get(), ifc->_context);
            if (_rval_handle.is_empty()) {
                lua_pushnil(L);
            }
            else {
                _rval_handle->get_ref();
            }
        }
        else
            lua_pushnil(L);
        $-(/if)$
        lua_setfield(L, -2, "_ret");
    $-(elif)$
        $-(if return.iref.false?)$
            $-(if return.ptr.true?)$
        static_assert(CHECK::meta_operator_exists<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'");
                if (_rval_)
            to_lua(*_rval_);
                $-(elif)$
        static_assert(CHECK::meta_operator_exists<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'");
        to_lua(_rval_);
                $-(/if)$
        $-(elif)$
        if (!_rval_.is_empty()){
            iref<::lua::registry_handle> _rval_handle = ::lua::wrap_object(_rval_.get(), ifc->_context);
            if (_rval_handle.is_empty()) {
                lua_pushnil(L);
            }
            else {
                _rval_handle->get_ref();
            }
        }
        else
            lua_pushnil(L);
        $-(/if)$
    $-(/if)$

    $-[args outarg?]$
        $-(if iref.false?)$
        static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
        to_lua($name$);
        $-(elif)$
        if (!$name$.is_empty()){
            iref<::lua::registry_handle> $name$_handle = ::lua::wrap_object($name$.get(), ifc->_context);
            if ($name$_handle.is_empty()) {
                lua_pushnil(L);
            }
            else {
                $name$_handle->get_ref();
            }
        }
        else
            lua_pushnil(L);
        $-(/if)$
        lua_setfield(L, -2, "$name$");

    $[/args]-$
$-(elif noutargs?="1")$
    $-[args outarg?]$
        $-(if iref.false?)$
        static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
        to_lua($name$);
        $-(elif)$
        if (!$name$.is_empty()){
            iref<::lua::registry_handle> $name$_handle = ::lua::wrap_object($name$.get(), ifc->_context);
            if ($name$_handle.is_empty()) {
                lua_pushnil(L);
            }
            else {
                $name$_handle->get_ref();
            }
        }
        else
            lua_pushnil(L);
        $-(/if)$
    $[/args]-$
$-(elif noutargs?)$
        const uint _res_count = $noutargs$ + 1;
        lua_createtable(L, 0, _res_count);
    $-[args outarg?]$
        $-(if iref.false?)$
        static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
        to_lua($name$);
        $-(elif)$
        if (!$name$.is_empty()){
            iref<::lua::registry_handle> $name$_handle = ::lua::wrap_object($name$.get(), ifc->_context);
            if ($name$_handle.is_empty()) {
                lua_pushnil(L);
            }
            else {
                $name$_handle->get_ref();
            }
        }
        else
            lua_pushnil(L);
        $ - (/ if)$
        lua_setfield(L, -2, "$name$");
    $[/args]-$
$(/if)-$

$-(if return.type?="void" noutargs?="0")$
        return 0;
$-(elif)$
        return 1;
$(/if)-$
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int $..name$_lua_dispatcher::lua_$name$$@index$( lua_State * L ){
    int res = lua_$name$$@index$_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool $..name$_lua_dispatcher::can_use_ffi_$name$$@index$(){
    const MetaDesc * dsc = nullptr;

$-[args]$
    dsc = coid::metastream::meta_find_type<$basetype$>();
    if(!dsc || !dsc->btype.is_plain())    return false;

$-[/args]$
    return true;
}

void $..name$_lua_dispatcher::get_ffi_inject_$name$$@index$(coid::token& header, coid::token& body){
    static const coid::token h = "typedef $return.type$ (*$..name$_$name$$@index$_fun)(void * ifc_this $-[args]$, $type$ $name$$size$$[/args]$)\n";
    header = h;
    static const coid::token b =
"$..name$.$name$_ffi = ffi.cast(\"$..name$_$name$$@index$_fun\",$..name$.$name$);\n"\
"function $..name$:$name$($-[args after=","]$$name$$[/args]$)\n"\
"   return $..name$.$name$_ffi(self.__cthis $-[args]$, $name$$[/args]$)\n"\
"end;\n";
    body = b;
}
/*
$return.type$ $..name$_lua_dispatcher::lua_$name$$@index$_ffi(void * ifc_this $-[args]$, $type$ $name$$size$$[/args]$){

}
*/
$-[/method]$
$-[event]$
////////////////////////////////////////////////////////////////////////////////
$return.type$ $..name$_lua_dispatcher::$name$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$) $-(if const?)$ const$(/if)$
{
$-(if internal?)$
    throw coid::exception("method not marked for scripting");
$-(elif)$
    DASSERT(_bound_events);
    //bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[$@index$];

    if (ev__->is_empty())
    $-(if default_event_body?)$ {
        $default_event_body$
        $-(if return.type?="void")$
        return;
        $-(/if)$
    }
    $-(elif !noevbody?)$
        return;
    $-(elif)$
        throw coid::exception("handler not implemented");
    $-(/if)$

    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

// check if metastream operator exists for non iref args
$-[args inarg? iref.false?]$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
$-[/args]$

// stream in args and lua function for event call
    ev__->get_ref();
    _object->get_ref();

$(if ninargs?)$
$-[args inarg?]$
    $-(if iref.true?)$
    if (!$name$.is_empty()) {
        iref<::lua::registry_handle> $name$_handle = ::lua::wrap_object($name$.get(), _context);
        if ($name$_handle.is_empty()) {
            lua_pushnil(L);
        }
        else {
            $name$_handle->get_ref();
        }
    }
    else {
        lua_pushnil(L);
    }
$-(elif)$
    lua_streamer<$basetype$>::to_lua($name$); // TODO: volatile streamers
    $-(/if)$
$-[/args]$

$-(/if)$
$-(if return.type?="void" !noutargs?)$
    const uint nres = 0;
$-(elif)$
    const uint nres = 1;
$(/if)-$

// call event
    int res = lua_pcall(L,$ninargs$ + 1,nres,0);
$-[args inarg?]$$(if volatile?)$
    // TODO: some volatile cleanup was here
$(/if)$
$-[/args]$

    if (res != 0) {
        ::lua::throw_lua_error(L,  "$..ns rest="::" after="::"$lua::$..name$.$name$():");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

$-(if !noutargs?)$
    $-(if return.type!="void")$
        $-(if return.iref?)$
    $return.type$ _rval_;
        $-(elif)$
    static_assert(CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'");
    threadcached<$return.type$> _rval_;
        $-(/if)$
    from_lua(_rval_);
    $-(/if)$
$-(elif)$
    $-(if return.type?="void" noutargs?="1")$
        $-(if !return.iref?)$
            $-[args outarg?]$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
            $-[/args]$
        $-(/if)$
    $-[args outarg?]$
        $-(if ptr?)$
    if ($name$)
        from_lua(*$name$);
        $-(elif)$
    from_lua($name$);
        $-(/if)$
    $-[/args]$
    $-(elif)$
    if (!lua_istable(L,-1)) throw coid::exception("invalid params");

        $-(if return.type!="void")$
            $-(if return.iref?)$
    $return.type$ _rval_;
            $-(elif)$
    static_assert(CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator for '$return.type$'");
    threadcached<$return.type$> _rval_;
            $-(/if)$
    lua_getfield(L, -1, "_ret");
    from_lua(_rval_);
        $(/if)-$

    $-[args outarg? iref.false?]$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'" );
    $-[/args]$
    $-[args outarg?]$

    lua_getfield(L,-1,"$name$");
        $-(if ptr?)$
    if ($name$)
        from_lua(*$name$);
        $-(elif)$
    from_lua($name$);
        $-(/if)$
    $-[/args]$
    $-(/if)$
$-(/if)$
    $-(if return.type!="void")$
    return _rval_;
    $-(/if)$
$-(/if)$
}

$-[/event]$
////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int $name$_lua_dispatcher::lualog_exc( lua_State * L )
{
    try {
        if (lua_gettop(L) == 0)
            return 0;

        const void* inst = 0;

        lua_insert(L, 1);

        if (lua_istable(L, -1) && lua_hasfield(L, -1, ::lua::_lua_cthis_key)) {
            lua_getfield(L, -1, ::lua::_lua_cthis_key);
            if (lua_isuserdata(L, -1)) {
                $ns rest = "::" after = "::"$lua::$name$_lua_dispatcher* ifc = reinterpret_cast<$ns rest = "::" after = "::"$lua::$name$_lua_dispatcher*>
                    (*static_cast<size_t*>(lua_touserdata(L, -1)));
                lua_pop(L, 1);

                inst = ifc;
                if (!ifc) {
                    throw coid::exception("Null interface object in log");
                }
            }

            lua_pop(L, 1);
        }

        intergen_interface::ifclog_ext(coid::log::none, coid::tokenhash("$ns rest="::" after="::"$$name$"),
            inst, lua_totoken(L, -1));

        lua_pop(L, 1);

        return 0;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

////////////////////////////////////////////////////////////////////////////////
int $name$_lua_dispatcher::lualog(lua_State * L) {
    int res = lualog_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
__declspec(noinline) int $name$_lua_dispatcher::luaquery_interface_exc( lua_State * L )
{
    try {

        if (lua_gettop(L) < 2) {
            throw coid::exception("Interface creator name or caller object is missing.");
        }

        lua_pushbot(L); // move object table onto top of the stack

        if (!lua_istable(L, -1) || !lua_hasfield(L,-1, ::lua::_lua_cthis_key))
            return 0;

        lua_getfield(L, -1, ::lua::_lua_cthis_key);

        if (!lua_isuserdata(L,-1))
            return 0;

        $ns rest = "::" after = "::"$lua::$name$_lua_dispatcher* ifc = reinterpret_cast<$ns rest = "::" after = "::"$lua::$name$_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        if (!ifc)
            throw coid::exception("Null interface object in query_interface");

        lua_pushbot(L); // move creator key onto top of the stack

        if (!lua_isstring(L, -1))
            throw coid::exception("Interface creator name missing.");

        coid::token tokey = lua_totoken(L, -1);

        typedef int(*fn_get)(lua_State * L, ::lua::interface_context*);
        fn_get get = reinterpret_cast<fn_get>(
            coid::interface_register::get_interface_creator(tokey));

        if (!get) {
            coid::charstr tmp = "interface creator ";
            tmp << tokey << " not found";
            throw coid::exception(tmp);
        }

        lua_pop(L, 3); // pop redundant data from stack

        get(L, ifc);
        return 1;
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return -1;
}

int $name$_lua_dispatcher::luaquery_interface(lua_State * L) {
    int res = luaquery_interface_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}


////////////////////////////////////////////////////////////////////////////////
_declspec(noinline) int $name$_lua_dispatcher::luarebind_events_exc( lua_State * L )
{
$-(if event?)$
    try {
        lua_pushvalue(L,1); // move first function argument on the top of the stack(caller object in this case)
        if (!lua_istable(L,-1) || !lua_hasfield(L, -1, ::lua::_lua_cthis_key))
            return 0;

        lua_getfield(L, -1, ::lua::_lua_cthis_key);
        if (!lua_isuserdata(L,-1))
            return 0;

        $ns rest="::" after="::"$lua::$name$_lua_dispatcher* ifc = reinterpret_cast<$ns rest="::" after="::"$lua::$name$_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        lua_pop(L, 1); // pop user data

        // now only script object with events is on the top of the stack

        if (ifc) {
            if (ifc->intergen_real_interface() != ifc) 
            {
                ifc->assign_safe(nullptr, nullptr);
                ifc->assign_safe(ifc, nullptr);
            }

            iref<::lua::registry_handle> val = new ::lua::registry_handle(L);
            if (lua_gettop(L) > 0)
                val->set_ref();
            ifc->bind_events(true, val, "");
         }
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return 0;
$-(elif)$
    return 0;
$-(/if)$
}

int $name$_lua_dispatcher::luarebind_events(lua_State * L) {
    int res = luarebind_events_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> $name$_lua_dispatcher::create_interface_object( bool make_weak )
{
    lua_State * L = _context->get_state();

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_rawgeti(L,LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
    
    if (!lua_hasfield(L, -1, lua_interface_class_name()))
    {
        register_interface_$name$(L);
    }

    lua_createtable(L, 0, 3);
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_cthis_key);

    lua_pushnumber(L, ints($hash$));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);

    lua_getfield(L, -2, lua_interface_class_name());
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);
    
    iref<::lua::registry_handle> obj;

    if (make_weak) {
        obj = new ::lua::weak_registry_handle(L);
        lua_getfield(L, -1, ::lua::_lua_cthis_key);
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_WEAK_IFC_MT_INDEX);
        lua_setmetatable(L,-2);
        lua_pop(L, 1);
        add_refcount();
    }
    else {
        obj = new ::lua::registry_handle(L);
    }

    obj->set_ref();

    lua_pop(L, 1); // pop interface metatable register table

#ifdef _DEBUG
    DASSERT(stack_top == lua_gettop(L));
#endif

    return obj;
}

$-(if event.empty!)$
////////////////////////////////////////////////////////////////////////////////
void $name$_lua_dispatcher::bind_events(bool force, iref<::lua::registry_handle> binding_object, const coid::token& script_class_name ) const
{
    if (!force && _bound_events)
        return;

    static token names[] = {
$-[event]$
        "$name$",
$-[/event]$
    };
    lua_State * L = nullptr;
    bool clear = false;

    if (binding_object.is_empty()) { // nullptr
        clear = true;
    }
    else if (binding_object->is_empty()) { // ref handle is not holding any object
        L = _context->get_state();
        _context->get_ref();
        if(!lua_hasfield(L, -1, script_class_name)){
            coidlog_error("$name$_lua_dispatcher::bind_events", "Given contex doesn't implements this class!");
            lua_pop(L, 1);
            return;
        }
        lua_getfield(L, -1, script_class_name);
        lua_insert(L, -2);
        lua_pop(L, 1);
    }
    else {
        L = binding_object->get_state();
    }

    for (int i = 0; i<$event.@size$; ++i)
    {
        _events[i]->release();

        if (clear) {
            continue;
        }
        _events[i]->set_state(L);
        lua_getfield(L, -1, names[i]);
        if (!lua_isfunction(L, -1)) {
            lua_pop(L, 1);
            continue;
        }

        _events[i]->set_ref();
    }

    _bound_events = true;
}

$-(/if)$

// --- registrar ---
int $name$_lua_dispatcher::register_interface_$name$(lua_State * L) {
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif
    lua_rawgeti(L,LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
    
    lua_createtable(L, 0, 0);

$-[method !static? !destroy ? !internal? !operator?]$
    lua_pushcfunction(L, &$..name$_lua_dispatcher::lua_$name$$@index$);
    lua_setfield(L, -2, "$name$");
$[/method]$
/*$-[event]$
    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "$name$");
$[/event]-$
  */  
$-(if event?)$
    lua_pushcfunction(L, &$name$_lua_dispatcher::luarebind_events);
    lua_setfield(L, -2, "rebind_events");
$-(/if)$

    lua_setfield(L, -2, lua_interface_class_name());
    lua_pop(L,1); // pop interface metatable register table

#ifdef _DEBUG
    DASSERT(lua_gettop(L) == stack_top); // ensure we left the stack in the initial state
#endif
    

    return 0;
}

int $name$_lua_dispatcher::register_implementation_$name$(lua_State * L, const coid::token& implementation_script_class_name)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_pushvalue(L, LUA_ENVIRONINDEX); // push script context

    lua_createtable(L, 0, 0);

$-[event]$
    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "$name$");
$[/event]-$

    lua_setfield(L, -2, implementation_script_class_name.is_empty()?lua_interface_class_name():implementation_script_class_name);
    lua_pop(L, 1); // pop script context

#ifdef _DEBUG
    DASSERT(lua_gettop(L) == stack_top); // ensure we left the stack in the initial state
#endif
    

    return 0;
}
// --- creators ---

$-[method creator? !ifccr?]$
////////////////////////////////////////////////////////////////////////////////
iref<$..name$_lua_dispatcher> $..name$_lua_dispatcher::$name$(lua_State * L, const ::lua::script_handle& script
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bind_class_name, const coid::token& bind_var_name, iref<::lua::registry_handle>* ctx )
{
    // create interface object
    iref<$..name$_lua_dispatcher> ifc = $..ns rest="::" after="::"$$..name$::$name$(new $..name$_lua_dispatcher$[args]$, $name$$[/args]$);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    iref<::lua::registry_handle> context = nullptr;

    if (script.has_context()){
        context = script.context();
    }
    else {
        context = new ::lua::lua_context(L);

        if (script.is_path()) {
            coid::token script_info;
            script_info = script.str();
            if (script_info.contains_back('\\') || script_info.contains_back('/')) {
                script_info.cut_left_group_back(coid::DIR_SEPARATORS);
            }
            context->get_ref();
            lua_pushtoken(L, script_info);
            lua_setfield(L, -2, ::lua::_lua_context_info_key);
            lua_pop(L, 1);
        }
    }

    if (ctx)
        *ctx = context;

    if (!script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif(script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ::lua::load_script(context, script_tok, script.url());
    }

    ifc->_context = new ::lua::weak_registry_handle(L);
    context->get_ref();
    ifc->_context->set_ref();
    ifc->_object = ifc->create_interface_object(false);

$-(if ..event?)$
    ifc->bind_events(false, ::lua::registry_handle::get_empty(), bind_class_name);
$-(/if)$

    if (bind_var_name) {
        context->get_ref();
        ifc->_object->get_ref();
        lua_setfield(L, -2, bind_var_name);
        lua_pop(L, 1);
    }

    return ifc;
}

$-(if !internal?)$
////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<$..ns rest="::" after="::"$$..name$> $..ns rest="::" after="::"$$..name$::$name$($[args rest=","]$ $type$ $name$$[/args]$)
///

int $..name$_lua_dispatcher::luacreator_$name$$@order$(lua_State * L, ::lua::interface_context* ifc )
{
    const int args_count = lua_gettop(L);

    if (args_count < $ninargs_nondef$ || args_count > $ninargs$) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "$..name$.$name$";
        throw coid::exception(tmp);
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).reset(L);

$-[args inarg? !nojs?]$
    lua_pushvalue(L, $@order$ + 1);
    $-(if iref.true?)$
        $basetype$ $name$;
        $-(if !defval.empty?)$
    if ($@order$ < args_count)
        from_lua($name$);
    else
        $name$ = $defval$;
        $-(elif)$
    from_lua($name$);
        $-(/if)$
    $-(elif)$
    static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator '$basetype$'");
        $-(if !defval.empty? ptr.true?)$
    threadcached<$basetype$> $name$__tmp;
    $basetype$ *$name$ = &$name$__tmp;
    if ($@order$ < args_count)
        from_lua($name$__tmp);
    else
        $name$ = $defval$;
        $-(elif !defval.empty?)$
    threadcached<$basetype$> $name$;
    if ($@order$ < args_count)
        from_lua($name$);
    else
        $name$ = $defval$;
        $-(elif)$
    threadcached<$basetype$> $name$;
    from_lua($name$);
        $-(/if)$
    $-(/if)$
$[/args]-$

//out params
$-[args outarg? !inarg?]$
    $basetype$ $name$;
$[/args]-$

    iref<$..name$_lua_dispatcher> nifc = $..ns rest="::" after="::"$$..name$::$name$(new $..name$_lua_dispatcher$[args]$, $(if ptr? outarg?)$&$(elif ptr? defval.empty? !specptr?)$&$(/if)$$name$$[/args]$);

    //stream out
$-(if noutargs?)$
    lua_createtable(L, 0, $noutargs$ + 1);
    if (nifc) {
        if (ifc) {
            nifc->_context = ifc->_context;
        }
        else {
            nifc->_context->set_state(L);
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            nifc->_context->set_ref();
        }

        nifc->create_interface_object(true)->get_ref();
    }
    else {
        lua_pushnil(L);
    }

    lua_setfield(L, -2, "ret");

    $-[args outarg?]$
        $-(if iref.false?)$
        static_assert(CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator for '$basetype$'");
        $-(/if)$
        to_lua($name$);
        lua_setfield(L, -2, "$name$");
    $[/args]-$
$-(elif)$
    if (nifc) {
        if (ifc) {
            nifc->_context = ifc->_context;
        }
        else {
            nifc->_context->set_state(L);
            lua_pushvalue(L, LUA_ENVIRONINDEX);
            nifc->_context->set_ref();
        }

        nifc->create_interface_object(true)->get_ref();
    }
    else {
        lua_pushnil(L);
    }
$-(/if)$

    return 1;
}

$ - (/ if)$
$ - [/ method]$
$ - (if virtual!)$
////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref <::lua::registry_handle> create_wrapper_$name$(::$ns rest = "::" after = "::"$$name$* orig, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!orig) return nullptr;

    iref<$ns rest="::" after="::"$lua::$name$_lua_dispatcher> ifc;
    iref <::lua::registry_handle> obj;

    if (orig->intergen_backend() == intergen_interface::backend::lua)
        obj = static_cast<$name$_lua_dispatcher*>(orig)->_object;

    if (obj.is_empty()) {
        // create interface object
        ifc.create(new $ns rest="::" after="::"$lua::$name$_lua_dispatcher(context, static_cast<::$ns rest="::" after="::"$$name$*>(orig)));

        obj = ifc->create_interface_object(true);
        ifc->_object = obj;
    }

    return obj;
}

$-(/if)$
////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_$name$( bool on )
{
    interface_register::register_interface_creator(
        "lua::register_class.$ns rest="_" after="_"$$name$",
        on ? (void*)&$name$_lua_dispatcher::register_interface_$name$
        : nullptr);

    interface_register::register_interface_creator(
        "lua::implement_class.$ns rest="_" after="_"$$name$",
        on ? (void*)&$name$_lua_dispatcher::register_implementation_$name$
        : nullptr);

$-[method creator? !ifccr?]$
    //c++ creator of Lua interface object
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$$..name$.$name$@creator.lua",
        on ? (void*)&$..name$_lua_dispatcher::$name$ : nullptr);
$-(if !internal?)$

    //creator from script
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$lua::$..name$.$name$",
        on ? (void*)&$..name$_lua_dispatcher::luacreator_$name$$@order$ : nullptr);
$-(/if)$
$-[/method]$
$-(if virtual!)$

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator(
        "$ns rest="::" after="::"$$name$@wrapper.lua",
        on ? (void*)&create_wrapper_$name$ : nullptr);
$-(/if)$
}

//auto-register the bind function
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&register_binders_for_$name$);

void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_$name$);
    return autoregger.get();
}

} //namespace lua
$-[ns]$
} //namespace $@value$
$-[/ns]$

$-[/iface]$$[/class]$

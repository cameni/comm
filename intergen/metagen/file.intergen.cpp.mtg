
//@file $name$ interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

$-[class]$$[iface]$
#include "$relpath$"
$-[/iface]$$[/class]$
#include "$hdr$"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>


static_assert(intergen_interface::VERSION == $version$, "interface must be rebuilt with a different intergen version");

using namespace coid;

$-[class iface.empty!]$
static_assert( std::is_base_of<policy_intrusive_base, ::$ns rest="::" after="::"$$class$>::value, "class '$class$' must be derived from policy_intrusive_base");

$-[iface]$
////////////////////////////////////////////////////////////////////////////////
// interface $[ns]$$@value$::$[/ns]$$name$ of class $..class$
$[ns]$
namespace $@value$ {
$-[/ns]$

///
class $name$_dispatcher : public $name$
{
    friend class $name$;

private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
$-(if !virtual?)$
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[$nifcmethods$];
$-[method !static?]$
 $-(if hasifc?)$
        _vtable1[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$ $-(if fnarg?)$$type$(*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$)$(if const?)$const$(/if)$>(&$name$__ifc_wrapper));
 $-(elif)$
        _vtable1[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$ $-(if fnarg?)$$type$($memfnclass after="::"$*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$)$(if const?)$const$(/if)$>(&::$....ns rest="::" after="::"$$....class$::$intname$));
 $-(/if)$
$-[/method]-$

        return _vtable1;
$-(elif)$
        return 0;
$-(/if)$
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))

$-[method capture?]$

    $return.type$ __capture__$(if operator?)$operator$(elif)$$name$$index$$(/if)$($[args rest=", "]$$type$ $name$$[/args]$)$(if const?)$ const$(/if)$
    {
        (*_capture) << uint16(_instid | $index$) $-[args inarg?]$ << $name$$[/args]$;
        return VT_CALL2($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
    }
$-[/method]$

$-[method hasifc?]$
    $return.type$ $name$__ifc_wrapper($[args rest=", "]$$type$ $name$$[/args]$)$(if const?)$ const$(/if)$
    {
        iref<$return.ifc$> __ret__ = $name$($[args rest=","]$$name$$[/args]$);
        if (!__ret__)
            return 0;

        typedef iref<$return.ifc$> (*fn_wrap)(policy_intrusive_base*, intergen_interface*);
        static fn_wrap wrapper = reinterpret_cast<fn_wrap>(
            coid::interface_register::get_interface_creator("$ns rest="::" after="::"$$name$@wrapper"));

        return wrapper ? wrapper(__ret__.get(), new $..name$_dispatcher) : 0;
    }
$[/method]-$

    static ifn_t* get_vtable_intercept()
    {
$-(if !virtual?)$
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[$nifcmethods$];
$-[method !static?]$
    $-(if capture? operator?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__operator));
    $-(elif capture?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__$name$$index$));
    $-(elif)$
        _vtable2[$@order$] = vtable1[$@order$];
    $-(/if)$
$-[/method]-$

        return _vtable2;
$-(elif)$
        return 0;
$-(/if)$
    }

$-[event pure?]$
    $return.type$ $name$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if fnarg?)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if const?)$ const$(/if)$ override { throw coid::exception("unreachable"); }
$-[/event]$

protected:

    COIDNEWDELETE($name$_dispatcher);

    $name$_dispatcher() {
    }

    virtual ~$name$_dispatcher() {
    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        $-[method capture? noutargs!]$
        case $index$: {
            $-[args inarg?]$
            $-(if token?)$
            coid::token $name$ = bin.string();
            $-(elif)$
            const $basetype$& $name$ = bin.fetch<$basetype$>();
            $-(/if)$
            $-[/args]$
            VT_CALL($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
            break;
        }
        $-[/method]$
        case UMAX32:
        default: throw coid::exception("unknown method id in $name$ capture dispatcher");
        }
    }
$-(if virtual!)$

    static iref<$name$> _generic_interface_creator(::$..ns rest="::" after="::"$$..class$* host, $name$* __here__)
    {
        iref<$name$> rval;

        $--(if varname?)$
        //an active interface (with events)
        if (host->$varname$ && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            $name$_dispatcher* dispatcher = __here__
                ? static_cast<$name$_dispatcher*>(__here__)
                : new $name$_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }
        $-(elif)$
        //a passive interface (no events)
        $name$_dispatcher* dispatcher = __here__
            ? static_cast<$name$_dispatcher*>(__here__)
            : new $name$_dispatcher;
        rval.create(dispatcher);

        dispatcher->set_host(host, 0, 0);
        $-(/if)$

        $-(if onconnect?)$
        host->$onconnect$();

        $-(/if)$
        $-(if onconnectev?)$
        rval->$onconnectev$();

        $-(/if)$
        return rval;
    }
$-(/if)$

public:

    // creator methods

$-[method creator? !ifccr?]$
    static iref<$..name$> $name$( $..name$* __here__$[args]$, $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ )
    {
        iref<::$....ns rest="::" after="::"$$....class$> __host__ = ::$....ns rest="::" after="::"$$....class$::$intname$($[args rest=", "]$$name$$[/args]$);
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

$-[/method]$
    ///Register interface creators in the global registry
    static void register_interfaces( bool on )
    {
$-(if virtual!)$
        interface_register::register_interface_creator(
            "$ns rest="::" after="::"$$name$@wrapper",
            on ? (void*)&_generic_interface_creator : nullptr);

$-(/if)$
$-(if onunload?)$
        static_assert(std::is_same<decltype(&::$..ns rest="::" after="::"$$..class$::$onunload$), intergen_interface::fn_unload_client>::value,
            "expected unload function to have (const coid::token& client, const coid::token& module, int mode) parameters");

        interface_register::register_interface_creator(
            "$ns rest="::" after="::"$$name$@unload",
            on ? (void*)&::$..ns rest="::" after="::"$$..class$::$onunload$ : nullptr);

$-(/if)$
$-[method creator? !ifccr?]$
        interface_register::register_interface_creator(
            "$..ns rest="::" after="::"$$..name$.$name$@$..hash$",
            on ? (void*)&$name$ : nullptr);
$-[/method]$
$-[method creator? ifccr?]$
        interface_register::register_interface_creator(
            "$..ns rest="::" after="::"$$..name$.$name$@$..hash$.ifc",
            on ? (void*)&::$....ns rest="::" after="::"$$....class$::$name$ : nullptr);
$-[/method]$
    }
};

coid::binstring* $name$_dispatcher::_capture = 0;
uint16 $name$_dispatcher::_instid = 0xffffU;
intergen_interface::ifn_t* $name$_dispatcher::_vtable2 = 0;
intergen_interface::ifn_t* $name$_dispatcher::_vtable1 = 0;
$-(if varname?)$

iref<$name$> $name$::intergen_active_interface(::$classnsx rest="::" after="::"$$class$* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<$name$> rval;
    rval.add_refcount(static_cast<$name$*>(host->$varname$.get()));

    return rval;
}

bool $name$::assign_safe(intergen_interface* client__, iref<$name$>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::$..ns rest="::" after="::"$$..class$* hostptr = host<::$..ns rest="::" after="::"$$..class$>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->$varname$;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client__;
    if (succ) {
        ifcvar = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<$name$*>(ifcvar.get()));

    return succ;
}
$-(/if)$

bool $name$::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<$name$>* pout)
{
    _host = host__;
    _vtable = $name$_dispatcher::get_vtable();
$-(if varname?)$

    return assign_safe(client__, pout);
$-(elif)$
    return true;
$-(/if)$
}

//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&$name$_dispatcher::register_interfaces);

void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&$name$_dispatcher::register_interfaces);
    return autoregger.get();
}

$-[ns]$
} //namespace $@value$
$-[/ns]$

$-(if event?)$
// events

$[..nss]$namespace $@value$ {
$[/..nss]-$

$-[event !implicit? !inherit?]$
$return.type$ $....class$::$intname$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if fnarg?)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if const?)$ const$(/if)$
{
    if (!$..varname$ $-(if ..inhmask?)$ || ($..varname$->iface<$..ns rest="::" after="::"$$..name$>()->_inhmask & (1<<$..ifc_bit$)) == 0$(/if)$) $-(if default_event_body?)$
        { $default_event_body$ }$(elif)$
        throw coid::exception() << "$name$" << " handler not implemented";$(/if)$
    else
        return $..varname$->event_dispatcher<$..ns rest="::" after="::"$$..name$>()->$name$($[args rest=", "]$$name$$[/args]$);
}
$[/event]-$

$[..nss]$} //namespace $@value$
$[/..nss]-$
$(/if)-$

$-[/iface]$$[/class]$

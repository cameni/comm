
//@file $name$ interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

$-[class]$$[iface]$
#include "$relpath$"
$-[/iface]$$[/class]$
#include "$hdr$"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>


static_assert(intergen_interface::VERSION == $version$, "interface must be rebuilt with a different intergen version");

using namespace coid;

$-[class iface.empty!]$
static_assert( std::is_base_of<policy_intrusive_base, ::$ns rest="::" after="::"$$class$>::value, "class '$class$' must be derived from policy_intrusive_base");

$-[iface]$
$-(if direct_inheritance?)$
static_assert($base$::is_derived_from_host_class<::$ns rest="::" after="::"$$class$>(),"class '::$ns rest="::" after="::"$$class$' must be derived from $base$ host class when using direct inheritance('|')");

$-(/if)$

////////////////////////////////////////////////////////////////////////////////
// implementation of interface $[ns]$$@value$::$[/ns]$$name$ of class $..class$
$[ns]$
namespace $@value$ {
$-[/ns]$

///
class $name$_implementation : public $name$
{
    friend class $name$;

private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
$-(if !virtual?)$
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[$(if direct_inheritance?)$$name$::_ifc_methods_count$(elif)$$nifcmethods$$(/if)$];
        
        $-(if direct_inheritance?)$
        typedef ifn_t*(*get_baseclass_vtable_fn)();
        get_baseclass_vtable_fn get_baseclass_vtable = static_cast<get_baseclass_vtable_fn>(interface_register::get_interface_creator("$baseclassns rest="_" after="_"$$baseclass$_dispatcher_get_vtable"_T));
        if(!get_baseclass_vtable)
        {
            throw coid::exception("Base class ($baseclassns rest="::" after="::"$$baseclass$_dispatcher) vtable getter function not registered!");
        }

        memcpy(_vtable1, get_baseclass_vtable(), sizeof(*_vtable1) * $base$::_ifc_methods_count);
        $-(/if)$
$-[method !static?]$
 $-(if hasifc?)$
        _vtable1[$(if ..direct_inheritance?)$$..base$::_ifc_methods_count + $(/if)$$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$ $-(if fnarg?)$$type$(*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$)$(if const?)$const$(/if)$>(&$name$__ifc_wrapper));
 $-(elif)$
        _vtable1[$(if ..direct_inheritance?)$$..base$::_ifc_methods_count + $(/if)$$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$ $-(if fnarg?)$$type$($memfnclass after="::"$*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$)$(if const?)$const$(/if)$>(&::$....ns rest="::" after="::"$$....class$::$intname$));
 $-(/if)$
$-[/method]-$

        return _vtable1;
$-(elif)$
        return 0;
$-(/if)$
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))

$-[method capture?]$

    $return.type$ __capture__$(if operator?)$operator$(elif)$$name$$index$$(/if)$($[args rest=", "]$$type$ $name$$[/args]$)$(if const?)$ const$(/if)$
    {
        (*_capture) << uint16(_instid | $index$) $-[args inarg?]$ << $name$$[/args]$;
        return VT_CALL2($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
    }
$-[/method]$

$-[method hasifc?]$
    $return.type$ $name$__ifc_wrapper($[args rest=", "]$$type$ $name$$[/args]$)$(if const?)$ const$(/if)$
    {
        iref<$return.ifc$> __ret__ = $name$($[args rest=","]$$name$$[/args]$);
        if (!__ret__)
            return 0;

        typedef iref<$return.ifc$> (*fn_wrap)(policy_intrusive_base*, intergen_interface*);
        static fn_wrap wrapper = reinterpret_cast<fn_wrap>(
            coid::interface_register::get_interface_creator("$ns rest="::" after="::"$$name$@wrapper"));

        return wrapper ? wrapper(__ret__.get(), new $..name$_dispatcher) : 0;
    }

$[/method]-$
    static ifn_t* get_vtable_intercept()
    {
$-(if !virtual?)$
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[$nifcmethods$];
$-[method !static?]$
    $-(if capture? operator?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__operator));
    $-(elif capture?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__$name$$index$));
    $-(elif)$
        _vtable2[$@order$] = vtable1[$@order$];
    $-(/if)$
$-[/method]-$

        return _vtable2;
$-(elif)$
        return 0;
$-(/if)$
    }

$-[event pure?]$
    $return.type$ $name$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if fnarg?)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if const?)$ const$(/if)$ override { throw coid::exception("unreachable"); }
$-[/event]$

protected:

    COIDNEWDELETE($name$_implementation);

    $name$_implementation() {
    }

    virtual ~$name$_implementation() {
    }

    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        $-[method capture? noutargs!]$
        case $index$: {
            $-[args inarg?]$
            $-(if token?)$
            coid::token $name$ = bin.string();
            $-(elif)$
            const $basetype$& $name$ = bin.fetch<$basetype$>();
            $-(/if)$
            $-[/args]$
            VT_CALL($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
            break;
        }
        $-[/method]$
        case UMAX32:
        default: throw coid::exception("unknown method id in $name$ capture dispatcher");
        }
    }
$-(if virtual!)$

    static iref<$name$> interface_creator(::$..ns rest="::" after="::"$$..class$* host)
    {
        iref<$name$> rval;

        $name$_implementation* interface = new $name$_implementation; 
        rval.create(interface);

        interface->set_host(host, 0, 0);

        $-(if onconnect?)$
        host->$onconnect$();

        $-(/if)$
        $-(if onconnectev?)$
        rval->$onconnectev$();

        $-(/if)$
        return rval;
    }
$-(/if)$

public:

    // creator methods

$-[method creator? !ifccr?]$
    static iref<$..name$> $name$( $..name$* __here__$[args]$, $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ )
    {
        iref<::$....ns rest="::" after="::"$$....class$> __host__ = ::$....ns rest="::" after="::"$$....class$::$intname$($[args rest=", "]$$name$$[/args]$);
        if (!__host__)
            return 0;
        return interface_creator(__host__.get());
    }

$-[/method]$
    ///Register interface creators in the global registry
    static void register_interfaces( bool on )
    {
$-(if virtual!)$
        interface_register::register_interface_creator(
            "$ns rest="::" after="::"$$name$@create_interface",
            on ? (void*)&interface_creator : nullptr);

$-(/if)$
$-(if onunload?)$
        static_assert(std::is_same<decltype(&::$..ns rest="::" after="::"$$..class$::$onunload$), intergen_interface::fn_unload_client>::value,
            "expected unload function to have (const coid::token& client, const coid::token& module, int mode) parameters");

        interface_register::register_interface_creator(
            "$ns rest="::" after="::"$$name$@unload",
            on ? (void*)&::$..ns rest="::" after="::"$$..class$::$onunload$ : nullptr);

$-(/if)$
$-[method creator? !ifccr?]$
        interface_register::register_interface_creator(
            "$..ns rest="::" after="::"$$..name$.$name$@$..hash$",
            on ? (void*)&$name$ : nullptr);
$-[/method]$
$-[method creator? ifccr?]$
        interface_register::register_interface_creator(
            "$..ns rest="::" after="::"$$..name$.$name$@$..hash$.ifc",
            on ? (void*)&::$....ns rest="::" after="::"$$....class$::$name$ : nullptr);
$-[/method]$
        interface_register::register_interface_creator(
            "$ns rest="_" after="_"$$name$_dispatcher_get_vtable",
            static_cast<void*>(&get_vtable));
    }
};

coid::binstring* $name$_implementation::_capture = 0;
uint16 $name$_implementation::_instid = 0xffffU;
intergen_interface::ifn_t* $name$_implementation::_vtable2 = 0;
intergen_interface::ifn_t* $name$_implementation::_vtable1 = 0;
$-(if varname?)$

iref<$name$_dispatcher> $name$_dispatcher::intergen_active_dispatcher(::$classnsx rest="::" after="::"$$class$* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<$name$_dispatcher> rval;
    rval.add_refcount(static_cast<$name$_dispatcher*>(host->$varname$.get()));

    return rval;
}

bool $name$_dispatcher::assign_safe(intergen_dispatcher* client__, iref<$name$_dispatcher>* pout)
{
    ::$..ns rest="::" after="::"$$..class$* hostptr = _interface->host<::$..ns rest="::" after="::"$$..class$>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_dispatcher>& dispatcher_var = hostptr->$varname$;
    coid::comm_mutex& mx = share_lock();
    if (dispatcher_var  == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !dispatcher_var  || !client__;
    if (succ) {
        dispatcher_var  = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<$name$_dispatcher*>(dispatcher_var.get()));

    return succ;
}
$-(/if)$

bool $name$::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<$name$>* pout)
{
    _host = host__;
    _vtable = $name$_implementation::get_vtable();
    return true;
}

//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&$name$_implementation::register_interfaces);

void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&$name$_implementation::register_interfaces);
    return autoregger.get();
}

$-[ns]$
} //namespace $@value$
$-[/ns]$

$-(if event?)$
// events

$[..nss]$namespace $@value$ {
$[/..nss]-$

////////////////////////////////////////////////////////////////////////////////
// implementation of iterface cxx dispatcher $[ns]$$@value$::$[/ns]$$name$ of class $..class$
namespace cxx{
$[ns]$
namespace $@value$ {
$-[/ns]$

class $name$_dispatcher : 
    public ::$ns rest="::" after="::"$$name$_dispatcher
{

};

$-[ns]$
} //namespace $@value$
$-[/ns]$
} // namespace cxx

$-[event !implicit? !inherit?]$
$return.type$ $....class$::$intname$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if fnarg?)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if const?)$ const$(/if)$
{
    if (!$..varname$ $-(if ..inhmask?)$ || ($..varname$->iface<$..ns rest="::" after="::"$$..name$>()->_inhmask & (1<<$..ifc_bit$)) == 0$(/if)$) $-(if default_event_body?)$
        { $default_event_body$ }$(elif)$
        throw coid::exception() << "$name$" << " handler not implemented";$(/if)$
    else
        return $..varname$->dispatcher<$..ns rest="::" after="::"$$..name$_dispatcher>()->$name$($[args rest=", "]$$name$$[/args]$);
}
$[/event]-$

$[..nss]$} //namespace $@value$
$[/..nss]-$
$(/if)-$
$-[/iface]$$[/class]$
